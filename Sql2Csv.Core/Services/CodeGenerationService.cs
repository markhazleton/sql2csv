using Microsoft.Data.Sqlite;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Sql2Csv.Core.Configuration;
using Sql2Csv.Core.Interfaces;
using System.Text;

namespace Sql2Csv.Core.Services;

/// <summary>
/// Service for generating code from database schema.
/// </summary>
public sealed class CodeGenerationService : ICodeGenerationService
{
    private readonly ILogger<CodeGenerationService> _logger;
    private readonly ISchemaService _schemaService;
    private readonly Sql2CsvOptions _options;

    /// <summary>
    /// Initializes a new instance of the <see cref="CodeGenerationService"/> class.
    /// </summary>
    /// <param name="logger">The logger.</param>
    /// <param name="schemaService">The schema service.</param>
    /// <param name="options">The application options.</param>
    public CodeGenerationService(
        ILogger<CodeGenerationService> logger,
        ISchemaService schemaService,
        IOptions<Sql2CsvOptions> options)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _schemaService = schemaService ?? throw new ArgumentNullException(nameof(schemaService));
        _options = options?.Value ?? throw new ArgumentNullException(nameof(options));
    }

    /// <inheritdoc />
    public async Task GenerateDtoClassesAsync(
        string connectionString,
        string outputDirectory,
        string namespaceName,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(connectionString);
        ArgumentException.ThrowIfNullOrWhiteSpace(outputDirectory);
        ArgumentException.ThrowIfNullOrWhiteSpace(namespaceName);

        _logger.LogInformation("Generating DTO classes in namespace: {Namespace}", namespaceName);

        try
        {
            Directory.CreateDirectory(outputDirectory);

            var tables = await _schemaService.GetTablesAsync(connectionString, cancellationToken);

            foreach (var table in tables)
            {
                cancellationToken.ThrowIfCancellationRequested();

                var dtoContent = GenerateDtoClass(table, namespaceName);
                var fileName = $"{ToPascalCase(table.Name)}Dto.cs";
                var filePath = Path.Combine(outputDirectory, fileName);

                await File.WriteAllTextAsync(filePath, dtoContent, cancellationToken);
                _logger.LogDebug("Generated DTO class: {FileName}", fileName);
            }

            _logger.LogInformation("Successfully generated {TableCount} DTO classes", tables.Count());
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error generating DTO classes");
            throw;
        }
    }

    private static string GenerateDtoClass(Core.Models.TableInfo table, string namespaceName)
    {
        var className = $"{ToPascalCase(table.Name)}Dto";
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Data transfer object for the {table.Name} table.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"public sealed record {className}");
        sb.AppendLine("{");

        foreach (var column in table.Columns)
        {
            var propertyName = ToPascalCase(column.Name);
            var csharpType = ConvertSqliteTypeToCSharpType(column.DataType, !column.IsNullable);

            sb.AppendLine("    /// <summary>");
            sb.AppendLine($"    /// Gets or sets the {column.Name}.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine($"    public {csharpType} {propertyName} {{ get; set; }}");
            sb.AppendLine();
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string ConvertSqliteTypeToCSharpType(string sqliteType, bool isNotNull)
    {
        var baseType = sqliteType.ToUpperInvariant() switch
        {
            "INTEGER" => "long",
            "TEXT" => "string",
            "BLOB" => "byte[]",
            "REAL" => "double",
            "NUMERIC" => "decimal",
            var type when type.StartsWith("VARCHAR") => "string",
            var type when type.StartsWith("CHAR") => "string",
            var type when type.StartsWith("NVARCHAR") => "string",
            var type when type.StartsWith("NCHAR") => "string",
            _ => "object"
        };

        // For reference types, nullable is handled differently
        if (baseType == "string" || baseType == "byte[]" || baseType == "object")
        {
            return isNotNull ? baseType : $"{baseType}?";
        }

        // For value types
        return isNotNull ? baseType : $"{baseType}?";
    }

    private static string ToPascalCase(string input)
    {
        if (string.IsNullOrEmpty(input))
            return input;

        var words = input.Split('_', StringSplitOptions.RemoveEmptyEntries);
        var result = new StringBuilder();

        foreach (var word in words)
        {
            if (word.Length > 0)
            {
                result.Append(char.ToUpperInvariant(word[0]));
                if (word.Length > 1)
                {
                    result.Append(word[1..].ToLowerInvariant());
                }
            }
        }

        return result.ToString();
    }
}
